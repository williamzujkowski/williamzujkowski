<svg width="800" height="600" 
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        
        <!-- Viewport clipping -->
        <clipPath id="terminalViewport">
            <rect x="0" y="40" width="800" 
                  height="560"/>
        </clipPath>
        
        <!-- Text glow filter -->
        <filter id="textGlow">
            <feGaussianBlur stdDeviation="0.5" result="coloredBlur"/>
            <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
        </filter>
    </defs>
    
    <!-- Window -->
    <rect width="800" height="600" 
          rx="8" ry="8" fill="#300a24"/>
    
    <!-- Title bar -->
    <rect width="800" height="40" rx="8" ry="8" fill="#2b2b2b"/>
    <rect y="20" width="800" height="20" fill="#2b2b2b"/>
    
    <!-- Window controls -->
    <circle cx="20" cy="20" r="6" fill="#ff5f56"/>
    <circle cx="40" cy="20" r="6" fill="#ffbd2e"/>
    <circle cx="60" cy="20" r="6" fill="#27c93f"/>
    
    <!-- Title -->
    <text x="400.0" y="25" font-family="Ubuntu Mono, Consolas, Monaco, 'Courier New', monospace" 
          font-size="13" fill="#cccccc" text-anchor="middle">william@ubuntu:~</text>
    
    <!-- Terminal viewport -->
    <g clip-path="url(#terminalViewport)">
        <rect y="40" width="800" 
              height="560" fill="#300a24"/>
        
        <!-- Terminal content area -->
        <g id="terminal-content" transform="translate(10, 50)">
            <!-- Dynamic content will be added here by JavaScript -->
        </g>
        
        <!-- Cursor - starts at initial position -->
        <rect id="cursor" x="10" y="50" 
              width="8.4" height="14" 
              fill="#ffffff">
            <animate attributeName="opacity" values="1;1;0;0" 
                     dur="1000ms" repeatCount="indefinite"/>
        </rect>
    </g>
    
    <!-- JavaScript animation engine -->
    <script type="text/javascript"><![CDATA[

// Terminal animation engine with debugging
(function() {
    'use strict';
    
    // Configuration
    const config = {"fontSize": 14, "fontFamily": "Ubuntu Mono, Consolas, Monaco, 'Courier New', monospace", "lineHeight": 19.599999999999998, "charWidth": 8.4, "padding": 10, "promptColor": "#87d75f", "textColor": "#ffffff", "typingSpeedMin": 40, "typingSpeedMax": 80, "typingSpeedAvg": 60, "viewportHeight": 540};
    const sequences = [{"type": "command", "prompt": "william@ubuntu:~$ ", "content": "echo \"Hello World\"", "output": {"content": "Hello World", "color": "#ffffff"}, "pause": 1000}, {"type": "command", "prompt": "william@ubuntu:~$ ", "content": "whoami", "output": {"content": "william", "color": "#ffffff"}, "pause": 1000}, {"type": "command", "prompt": "william@ubuntu:~$ ", "content": "date", "output": {"content": "Sun Jan 19 14:45:23 EST 2025", "color": "#ffffff"}, "pause": 2000}];
    
    // SVG namespace
    const svgNS = "http://www.w3.org/2000/svg";
    
    // Terminal state
    const terminal = {
        lines: [],           // Array of completed lines
        currentLine: null,   // Current line element being typed
        currentText: '',     // Current line text
        cursorX: 0,          // Cursor position in characters
        cursorY: 0,          // Cursor position in lines
        totalHeight: 0,      // Total height of content
        scrollOffset: 0,     // Current scroll offset
        isTyping: false,     // Currently typing flag
        sequenceIndex: 0,    // Current sequence being processed
        startTime: Date.now()
    };
    
    // Debug logging
    function log(message) {
        if (typeof console !== 'undefined' && console.log) {
            console.log('[Terminal]', message);
        }
    }
    
    // Get DOM elements with error handling
    function initializeElements() {
        const contentGroup = document.getElementById('terminal-content');
        const cursor = document.getElementById('cursor');
        
        if (!contentGroup) {
            log('ERROR: terminal-content element not found');
            return null;
        }
        if (!cursor) {
            log('ERROR: cursor element not found');
            return null;
        }
        
        return { contentGroup, cursor };
    }
    
    // Utility functions
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function getTypingSpeed() {
        const r = Math.random();
        if (r < 0.1) {
            return Math.floor(Math.random() * (500 - 200) + 200);
        } else if (r < 0.3) {
            return Math.floor(Math.random() * (config.typingSpeedMax - config.typingSpeedAvg) + config.typingSpeedAvg);
        } else {
            return Math.floor(Math.random() * (config.typingSpeedAvg - config.typingSpeedMin) + config.typingSpeedMin);
        }
    }
    
    // Create a new text line element
    function createLineElement(y, color) {
        const text = document.createElementNS(svgNS, 'text');
        text.setAttribute('x', '0');
        text.setAttribute('y', String(y + config.fontSize));
        text.setAttribute('font-family', config.fontFamily);
        text.setAttribute('font-size', String(config.fontSize));
        text.setAttribute('fill', color || config.textColor);
        text.setAttribute('filter', 'url(#textGlow)');
        return text;
    }
    
    // Update cursor position
    function updateCursor(cursor, x, y) {
        if (!cursor) return;
        cursor.setAttribute('x', String(config.padding + x));
        cursor.setAttribute('y', String(40 + config.padding + y));
    }
    
    // Main animation function
    async function runAnimation() {
        log('Starting animation...');
        
        const elements = initializeElements();
        if (!elements) {
            log('Failed to initialize elements');
            return;
        }
        
        const { contentGroup, cursor } = elements;
        
        // Show initial prompt immediately
        log('Displaying initial prompt...');
        const firstSequence = sequences[0];
        if (firstSequence && firstSequence.type === 'command') {
            const prompt = firstSequence.prompt || '$ ';
            const initialLine = createLineElement(0, config.promptColor);
            initialLine.textContent = prompt;
            contentGroup.appendChild(initialLine);
            terminal.currentLine = initialLine;
            terminal.currentText = prompt;
            terminal.cursorX = prompt.length;
            updateCursor(cursor, terminal.cursorX * config.charWidth, 0);
        }
        
        // Process a command sequence
        async function processCommand(sequence) {
            const prompt = sequence.prompt || '$ ';
            const command = sequence.content || '';
            
            log(`Processing command: ${command}`);
            
            // If this is the first command and we already showed the prompt, just type the command
            if (terminal.currentLine && terminal.currentText === prompt) {
                // Type command character by character
                for (let i = 0; i < command.length; i++) {
                    terminal.currentText += command[i];
                    terminal.currentLine.textContent = terminal.currentText;
                    terminal.cursorX++;
                    updateCursor(cursor, terminal.cursorX * config.charWidth, terminal.cursorY * config.lineHeight);
                    await sleep(getTypingSpeed());
                }
            } else {
                // Create new line with prompt
                terminal.currentLine = createLineElement(terminal.cursorY * config.lineHeight, config.promptColor);
                terminal.currentLine.textContent = prompt;
                contentGroup.appendChild(terminal.currentLine);
                terminal.currentText = prompt;
                terminal.cursorX = prompt.length;
                
                updateCursor(cursor, terminal.cursorX * config.charWidth, terminal.cursorY * config.lineHeight);
                
                // Type command character by character
                for (let i = 0; i < command.length; i++) {
                    terminal.currentText += command[i];
                    terminal.currentLine.textContent = terminal.currentText;
                    terminal.cursorX++;
                    updateCursor(cursor, terminal.cursorX * config.charWidth, terminal.cursorY * config.lineHeight);
                    await sleep(getTypingSpeed());
                }
            }
            
            // Move to next line
            await newLine();
            
            // Process output if present
            if (sequence.output) {
                await sleep(200);
                const outputLines = sequence.output.content.split('\n');
                const outputColor = sequence.output.color || config.textColor;
                
                for (const line of outputLines) {
                    await printLine(line, outputColor);
                }
            }
        }
        
        // Print a line instantly
        async function printLine(text, color) {
            const line = createLineElement(terminal.cursorY * config.lineHeight, color);
            line.textContent = text;
            contentGroup.appendChild(line);
            
            terminal.lines.push(line);
            terminal.currentLine = null;
            terminal.currentText = '';
            terminal.cursorX = 0;
            terminal.cursorY++;
            
            await checkScroll();
            updateCursor(cursor, 0, terminal.cursorY * config.lineHeight);
            await sleep(20);
        }
        
        // Move to next line
        async function newLine() {
            if (terminal.currentLine) {
                terminal.lines.push(terminal.currentLine);
            }
            
            terminal.currentLine = null;
            terminal.currentText = '';
            terminal.cursorX = 0;
            terminal.cursorY++;
            
            await checkScroll();
            updateCursor(cursor, 0, terminal.cursorY * config.lineHeight);
        }
        
        // Check and perform scrolling
        async function checkScroll() {
            const visibleLines = Math.floor(config.viewportHeight / config.lineHeight);
            
            if (terminal.cursorY >= visibleLines) {
                terminal.scrollOffset += config.lineHeight;
                const newTransform = `translate(${config.padding}, ${40 + config.padding - terminal.scrollOffset})`;
                contentGroup.setAttribute('transform', newTransform);
                await sleep(150);
            }
        }
        
        // Process all sequences
        try {
            log(`Processing ${sequences.length} sequences...`);
            
            // Start with first command already partially shown
            let startIndex = 0;
            if (sequences[0] && sequences[0].type === 'command') {
                await processCommand(sequences[0]);
                startIndex = 1;
            }
            
            // Process remaining sequences
            for (let i = startIndex; i < sequences.length; i++) {
                const sequence = sequences[i];
                
                if (sequence.delay) {
                    await sleep(sequence.delay);
                }
                
                switch (sequence.type) {
                    case 'command':
                        await processCommand(sequence);
                        break;
                        
                    case 'text':
                    case 'output':
                    case 'ascii':
                        const lines = sequence.content.split('\n');
                        const color = sequence.color || config.textColor;
                        for (const line of lines) {
                            await printLine(line, color);
                        }
                        break;
                }
                
                const pause = sequence.pause || 600;
                await sleep(pause);
            }
            
            log('Animation complete');
        } catch (error) {
            log('Error during animation: ' + error.toString());
        }
    }
    
    // Start the animation when ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', runAnimation);
    } else {
        // Small delay to ensure SVG is fully rendered
        setTimeout(runAnimation, 100);
    }
})();

    ]]></script>
</svg>